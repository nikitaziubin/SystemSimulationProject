<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Satellite Simulation with Orbits & Connections</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.4;
            padding: 15px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            height: 95vh;
        }
        h1, h2 {
            text-align: center;
            color: #333;
            margin-top: 0;
        }
        #main-container {
            display: flex;
            flex-grow: 1;
            gap: 20px;
            min-height: 450px; /* Increased min height */
        }
        #simulation-area {
            position: relative; /* Crucial for absolute positioning */
            border: 1px solid #aaa;
            background-color: #0a0a1a; /* Very dark blue/black */
            overflow: hidden; /* Hide elements outside */
            flex-basis: 65%;
            min-height: 450px;
        }
        #info-log-area {
             flex-basis: 35%;
             display: flex;
             flex-direction: column;
        }

        /* Stars */
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            /* Let JS set size, top, left, opacity */
            z-index: 1; /* Behind everything */
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        /* Earth */
        #earth {
            position: absolute;
            width: 15%; /* Percentage of simulation area */
            padding-bottom: 15%; /* Make height equal to width for aspect ratio */
            height: 0; /* Height is controlled by padding-bottom */
            background-color: #3a6d9c; /* Earthy blue */
             /* Simple gradient/texture */
             background-image: radial-gradient(circle at 30% 30%, #a7c7e7 10%, #5a8dbb 40%, #3a6d9c 70%);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 25px rgba(100, 150, 255, 0.6), inset 5px 5px 15px rgba(0,0,0,0.3); /* Inner shadow for depth */
            z-index: 5;
        }

        /* SVG Overlay for Lines */
        #connection-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15; /* Below satellites, above stations/earth */
            pointer-events: none; /* Allow clicks to pass through */
        }
        #connection-lines line {
            stroke-width: 1.5px;
            stroke-linecap: round;
        }
        .line-connected {
            stroke: #FF9800; /* Orange */
            stroke-dasharray: 4, 4; /* Dashed line */
            transition: stroke 0.3s ease;
        }
         .line-priority-connect {
             stroke: #ffeb3b; /* Yellow for priority */
             stroke-dasharray: 5, 3;
             stroke-width: 1.8px;
              transition: stroke 0.3s ease;
         }

        .station, .satellite {
            position: absolute;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
            transform: translate(-50%, -50%);
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }
        .station {
            width: 25px; /* Smaller stations */
            height: 25px;
            background-color: #4CAF50;
            border: 2px solid #388E3C;
            z-index: 10; /* Above Earth */
            /* Position calculated dynamically */
        }
        .station.offline {
            background-color: #757575;
            border-color: #424242;
        }
        .satellite {
            width: 14px; /* Smaller satellites */
            height: 14px;
            background-color: #03A9F4;
            border: 2px solid #0288D1;
            z-index: 20; /* Above lines */
            /* Position calculated dynamically */
        }
        .satellite.priority {
            background-color: #ffeb3b;
            color: #333;
            border-color: #fbc02d;
        }
        .satellite.damaged {
            background-color: #f44336;
            border-color: #d32f2f;
            opacity: 0.4;
        }
         /* Remove border indicators for connected/queued, use line instead */
        /* .satellite.connected { border-color: #FF9800; } */
        /* .satellite.queued { border-color: #ffffff; } */

        #controls { /* ... (same as before) ... */
            padding: 10px;
            text-align: center;
            background: #e0e0e0;
            border-bottom: 1px solid #ccc;
        }
         #controls button { padding: 8px 15px; margin: 0 5px; cursor: pointer; }
         #simTimeDisplay { font-weight: bold; margin-left: 20px; }
        #log-area { /* ... (same as before) ... */
            flex-grow: 1;
            background: #fff;
            border: 1px solid #ccc;
            padding: 0;
            display: flex;
            flex-direction: column;
        }
         #log-area h2 { margin: 0; padding: 5px; background: #e0e0e0; font-size: 1.1em; border-bottom: 1px solid #ccc; }
        #log-content { /* ... (same as before) ... */
             padding: 8px;
             overflow-y: scroll;
             font-size: 0.8em;
             flex-grow: 1;
             background-color: #f8f8f8;
         }
         .log-entry { margin-bottom: 3px; }
         .log-time { font-weight: bold; color: #555; }
         .log-type-CONNECT { color: #4CAF50; }
         .log-type-DISCONNECT { color: #ff9800; }
         .log-type-QUEUE { color: #607d8b; }
         .log-type-DATA_TX { color: #00bcd4; }
         .log-type-ERROR { color: #f44336; font-weight: bold;}
         .log-type-MAINTENANCE { color: #9c27b0; }
         .log-type-INFO { color: #777; }
         .log-type-INIT { color: #444; }
         .log-type-START { color: #2a9fd6; font-weight: bold; }
         .log-type-STOP { color: #2a9fd6; font-weight: bold; }
         .log-type-END { color: #2a9fd6; font-weight: bold; }

    </style>
</head>
<body>

    <h1>Satellite Network Simulation (Real-time with Orbits & Connections)</h1>

    <div id="main-container">
        <div id="simulation-area">
             <div id="earth"></div>
             <svg id="connection-lines" width="100%" height="100%">
                 </svg>
            </div>

        <div id="info-log-area">
             <div id="controls">
                 <button id="startBtn">Start</button>
                 <button id="stopBtn" disabled>Stop</button>
                 <span id="simTimeDisplay">Sim Time: 00:00:00</span>
             </div>
            <div id="log-area">
                <h2>Log</h2>
                <div id="log-content"></div>
            </div>
        </div>
    </div>


    <script>
        // --- Simulation Parameters ---
        const SIMULATION_TIME_SCALE = 100; // Slightly slower time scale
        const UPDATE_INTERVAL_MS = 40; // Faster updates (25 FPS)
        const SIM_STEP_SECONDS = (UPDATE_INTERVAL_MS / 1000) * SIMULATION_TIME_SCALE;

        const NUM_SATELLITES = 25; // Even more satellites
        const NUM_STATIONS = 3;
        const NUM_STARS = 200; // Number of background stars

        const STATION_CAPACITIES = [2, 3, 4];
        // Station positions are now calculated relative to Earth

        const SATELLITE_DATA_MIN_GB = 5;
        const SATELLITE_DATA_MAX_GB = 50;
        const SATELLITE_DATA_LIMIT_PER_CONTACT_GB = 10;
        const PRIORITY_SATELLITE_PROBABILITY = 0.15;
        const DAMAGED_SATELLITE_PROBABILITY = 0.08;

        const NORMAL_TRANSMISSION_SPEED_GB_PER_SECOND = 0.5 / 60;
        const BURST_TRANSMISSION_SPEED_GB_PER_SECOND = 1.5 / 60;

        // --- Visual Parameters (Percentages of Sim Area) ---
        const EARTH_CENTER = { x: 50, y: 50 };
        const EARTH_RADIUS_PERCENT = 7.5; // Half of Earth div width/height (15%)
        const MIN_ORBITAL_RADIUS_PERCENT = 12; // Start orbits further out
        const MAX_ORBITAL_RADIUS_PERCENT = 48; // Allow orbits closer to edge
        const MIN_ANGULAR_VELOCITY = 0.0001;
        const MAX_ANGULAR_VELOCITY = 0.0005;
        const MAX_CONNECTION_DISTANCE = 40; // Max visual distance for connection

        // Maintenance schedule
        const STATION_MAINTENANCE = {
            0: [[7200, 10800]],
            1: [[18000, 21600]],
        };

        const TRANSMISSION_ERROR_PROBABILITY_PER_STEP = 0.05;
        const JAMMING_PROBABILITY_PER_STEP = 0.02;
        const ERROR_DATA_REDUCTION_FACTOR = 0.5;

        // --- DOM Elements ---
        const simArea = document.getElementById('simulation-area');
        const logContent = document.getElementById('log-content');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const simTimeDisplay = document.getElementById('simTimeDisplay');
        const earthElement = document.getElementById('earth');
        const svgLines = document.getElementById('connection-lines'); // Reference SVG layer

        // --- Global State ---
        let satellites = [];
        let stations = [];
        let simulationTimeSeconds = 0;
        let simulationIntervalId = null;
        let logCounter = 0;
        let simAreaRect = null; // To store dimensions for coordinate conversion

        // --- Utility Functions ---
        function formatTime(totalSeconds) { /* ... (same as before) ... */
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
         }

        function logEvent(simTimeSec, type, message) { /* ... (same as before) ... */
             logCounter++;
             const entry = document.createElement('div');
             entry.classList.add('log-entry');
             const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
             entry.innerHTML = `<span class="log-time">${formatTime(simTimeSec)}</span> <span class="log-type log-type-${type}">[${type}]</span> ${safeMessage}`;
             logContent.appendChild(entry);
             if (logContent.children.length > 300) { logContent.removeChild(logContent.firstChild); }
             logContent.scrollTop = logContent.scrollHeight;
         }

        function distance(pos1, pos2) { /* ... (same as before) ... */
             return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
         }

        // Helper to get element center coordinates in pixels relative to simArea
        function getElementCenterPx(element) {
             if (!simAreaRect) simAreaRect = simArea.getBoundingClientRect();
             const elemRect = element.getBoundingClientRect();
             return {
                 x: (elemRect.left + elemRect.width / 2) - simAreaRect.left,
                 y: (elemRect.top + elemRect.height / 2) - simAreaRect.top
             };
         }

        // Helper to create stars
         function createStars(count) {
            for (let i = 0; i < count; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                const size = Math.random() * 2 + 0.5; // 0.5px to 2.5px size
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.opacity = Math.random() * 0.5 + 0.3; // 0.3 to 0.8 opacity
                simArea.appendChild(star);
             }
        }

        // --- Classes ---
        class Satellite {
            constructor(id, priority, initialData, dataLimit) {
                this.id = id;
                this.priority = priority;
                // ... (orbital parameters, data, status - same as before) ...
                this.dataToSend = initialData;
                this.dataLimitPerContact = dataLimit;
                this.status = "operational";
                this.firstContactDone = false;
                this.connectedToStationId = null;
                this.connectionStartTime = -1;
                this.dataSentThisContact = 0;
                this.isQueued = false; // Not visually represented now, but useful for logic

                this.orbitalRadius = MIN_ORBITAL_RADIUS_PERCENT + Math.random() * (MAX_ORBITAL_RADIUS_PERCENT - MIN_ORBITAL_RADIUS_PERCENT);
                const radiusRatio = (this.orbitalRadius - MIN_ORBITAL_RADIUS_PERCENT) / (MAX_ORBITAL_RADIUS_PERCENT - MIN_ORBITAL_RADIUS_PERCENT);
                this.angularVelocity = MAX_ANGULAR_VELOCITY - radiusRatio * (MAX_ANGULAR_VELOCITY - MIN_ANGULAR_VELOCITY);
                this.currentAngle = Math.random() * 2 * Math.PI;
                this.position = { x: 0, y: 0 };

                // Create DOM element
                this.domElement = document.createElement('div');
                this.domElement.id = `sat-${id}`;
                this.domElement.classList.add('satellite');
                if (this.priority) this.domElement.classList.add('priority');
                this.domElement.textContent = `S${id}`;
                simArea.appendChild(this.domElement);

                // Create SVG line element (initially hidden)
                this.lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                this.lineElement.setAttribute('id', `line-sat-${id}`);
                this.lineElement.setAttribute('x1', '0'); this.lineElement.setAttribute('y1', '0');
                this.lineElement.setAttribute('x2', '0'); this.lineElement.setAttribute('y2', '0');
                this.lineElement.style.display = 'none'; // Hidden initially
                svgLines.appendChild(this.lineElement);

                this.calculatePosition();
                this.updateDOMPosition();
            }

            calculatePosition() { /* ... (same as before) ... */
                 this.position.x = EARTH_CENTER.x + this.orbitalRadius * Math.cos(this.currentAngle);
                 this.position.y = EARTH_CENTER.y + this.orbitalRadius * Math.sin(this.currentAngle);
            }

             updatePosition(deltaTimeSeconds) {
                if (this.isDamaged()) return;
                this.currentAngle += this.angularVelocity * deltaTimeSeconds;
                this.currentAngle %= (2 * Math.PI);
                this.calculatePosition();
                this.updateDOMPosition();

                // Update line position if connected
                if (this.connectedToStationId !== null) {
                    const station = stations.find(st => st.id === this.connectedToStationId);
                    if (station) {
                         this.updateConnectionLine(station);
                    } else { // Should not happen, but handle defensively
                         this.disconnect();
                    }
                 }
            }

             updateDOMPosition() { /* ... (same as before) ... */
                 this.domElement.style.left = `${this.position.x}%`;
                 this.domElement.style.top = `${this.position.y}%`;
             }

             updateConnectionLine(station) {
                 if (!station || !this.lineElement) return;
                 const satCoords = getElementCenterPx(this.domElement);
                 const stationCoords = getElementCenterPx(station.domElement);

                 this.lineElement.setAttribute('x1', satCoords.x);
                 this.lineElement.setAttribute('y1', satCoords.y);
                 this.lineElement.setAttribute('x2', stationCoords.x);
                 this.lineElement.setAttribute('y2', stationCoords.y);

                 // Set style based on priority
                 this.lineElement.setAttribute('class', this.priority ? 'line-priority-connect' : 'line-connected');
                 this.lineElement.style.display = 'block'; // Make visible
             }

             hideConnectionLine() {
                 if (this.lineElement) {
                     this.lineElement.style.display = 'none';
                 }
             }


            isDamaged() { return this.status === "damaged"; }
            needsConnection() { return this.dataToSend > 0 && this.connectedToStationId === null && !this.isDamaged(); }

            connect(stationId, currentTime) {
                 this.connectedToStationId = stationId;
                 this.connectionStartTime = currentTime;
                 this.dataSentThisContact = 0;
                 this.isQueued = false; // Ensure queue flag is off
                 this.updateDOMState();
                 // Update line immediately
                 const station = stations.find(st => st.id === stationId);
                 this.updateConnectionLine(station);
            }

            disconnect() {
                 const wasConnected = this.connectedToStationId !== null;
                 this.connectedToStationId = null;
                 this.connectionStartTime = -1;
                 this.isQueued = false;
                 this.updateDOMState();
                 if (wasConnected) {
                    this.hideConnectionLine();
                 }
            }

            transmitData(amountSeconds, currentTime) { /* ... (same logic including range check) ... */
                 if (this.connectedToStationId === null || this.isDamaged()) return 0;
                 const connectedStation = stations.find(st => st.id === this.connectedToStationId);
                 if (!connectedStation) { this.disconnect(); return 0; } // Defensive check

                 const currentDist = distance(this.position, connectedStation.position);
                 if (currentDist > MAX_CONNECTION_DISTANCE * 1.05) { // Tighter range check now
                     logEvent(currentTime, "DISCONNECT", `Sat-${this.id} moved out of range from Sta-${this.connectedToStationId} (Dist: ${currentDist.toFixed(1)}).`);
                     connectedStation.disconnectSatellite(this.id); // Let station handle disconnect
                     return 0;
                 }
                 // --- Transmission Logic (same as before) ---
                let currentSpeed = this.firstContactDone ? NORMAL_TRANSMISSION_SPEED_GB_PER_SECOND : BURST_TRANSMISSION_SPEED_GB_PER_SECOND;
                let potentialData = currentSpeed * amountSeconds;
                let wasJammed = false, wasError = false;
                if (Math.random() < JAMMING_PROBABILITY_PER_STEP) { potentialData = 0; wasJammed = true; logEvent(currentTime, "ERROR", `JAMMING: Sat-${this.id} -> Sta-${this.connectedToStationId}.`); }
                else if (Math.random() < TRANSMISSION_ERROR_PROBABILITY_PER_STEP) { potentialData *= ERROR_DATA_REDUCTION_FACTOR; wasError = true; logEvent(currentTime, "ERROR", `TX Error: Sat-${this.id} -> Sta-${this.connectedToStationId}.`); }
                const remainingInData = this.dataToSend;
                const remainingInContact = this.dataLimitPerContact - this.dataSentThisContact;
                const transmitted = Math.max(0, Math.min(potentialData, remainingInData, remainingInContact));
                this.dataToSend -= transmitted;
                this.dataSentThisContact += transmitted;
                if (transmitted > 0 && !this.firstContactDone) this.firstContactDone = true;
                if (transmitted > 0){ logEvent(currentTime, "DATA_TX", `Sat-${this.id} -> Sta-${this.connectedToStationId}: Sent ${transmitted.toFixed(3)} GB.`); } // Simplified log
                return transmitted;
            }

            setDamaged() { /* ... (same as before, disconnect hides line) ... */
                 this.status = "damaged";
                 this.disconnect();
                 this.updateDOMState();
            }

            // Removed setQueued - state tracked but not visually different on sat now
            // setQueued(state) { ... }

            updateDOMState() { // Simpler now - only damage status
                 this.domElement.classList.toggle('damaged', this.isDamaged());
                 // Connection indicated by line
                 // this.domElement.classList.toggle('connected', this.connectedToStationId !== null);
                 // this.domElement.classList.toggle('queued', this.isQueued && this.connectedToStationId === null);
            }
        }

        class GroundStation {
            constructor(id, capacity, position, maintenanceSchedule) { // Position IS used now
                this.id = id;
                this.capacity = capacity;
                this.position = position; // {x, y} percentages - Calculated on Earth edge
                this.maintenanceSchedule = maintenanceSchedule || [];
                this.connectedSatellites = {};
                this.queue = [];
                this.status = "online";

                this.domElement = document.createElement('div');
                this.domElement.id = `station-${id}`;
                this.domElement.classList.add('station');
                this.domElement.style.left = `${position.x}%`;
                this.domElement.style.top = `${position.y}%`;
                this.domElement.textContent = `G${id}`;
                simArea.appendChild(this.domElement);
                 this.updateDOMState();
            }

            isOnline() { return this.status === "online"; }
            hasCapacity() { return Object.keys(this.connectedSatellites).length < this.capacity; }

            updateStatus(currentTime) { /* ... (same logic, disconnectSatellite calls sat.disconnect) ... */
                const wasOffline = (this.status === "offline_maintenance");
                let shouldBeOffline = false;
                for (const [start, end] of this.maintenanceSchedule) { if (currentTime >= start && currentTime < end) { shouldBeOffline = true; break; }}
                this.status = shouldBeOffline ? "offline_maintenance" : "online";
                const isOffline = !this.isOnline();
                if (isOffline && !wasOffline) {
                    logEvent(currentTime, "MAINTENANCE", `Station-${this.id} starting maintenance.`);
                    const connectedIds = Object.keys(this.connectedSatellites);
                    connectedIds.forEach(satId => { const sat = this.disconnectSatellite(satId); if (sat) logEvent(currentTime, "DISCONNECT", `Sat-${sat.id} disconnected (Sta-${this.id} Maintenance).`); });
                    // Clear queue (satellites no longer visually marked as queued)
                    // this.queue.forEach(sat => sat.setQueued(false));
                    this.queue = [];
                    logEvent(currentTime, "MAINTENANCE", `Station-${this.id} queue cleared.`);
                } else if (!isOffline && wasOffline) { logEvent(currentTime, "MAINTENANCE", `Station-${this.id} back online.`); }
                this.updateDOMState();
             }

            addToQueue(satellite, currentTime) { /* ... (same logic) ... */
                 if (this.connectedSatellites[satellite.id] || this.queue.some(s => s.id === satellite.id)) return false;
                 this.queue.push(satellite);
                 this.queue.sort((a, b) => b.priority - a.priority);
                 // satellite.setQueued(true); // No visual change on sat
                 logEvent(currentTime, "QUEUE", `Station-${this.id} full. Sat-${satellite.id} queued (Prio:${satellite.priority}). Q:${this.queue.length}`);
                 return true;
            }

            connectSatellite(satellite, currentTime) { /* ... (same logic, sat.connect updates line) ... */
                 if (this.hasCapacity() && this.isOnline()) {
                     this.connectedSatellites[satellite.id] = satellite;
                     satellite.connect(this.id, currentTime); // Connects sat & draws line
                     return true;
                 }
                 return false;
            }

            disconnectSatellite(satelliteId) { /* ... (same logic, sat.disconnect hides line) ... */
                 if (this.connectedSatellites[satelliteId]) {
                     const sat = this.connectedSatellites[satelliteId];
                     delete this.connectedSatellites[satelliteId];
                     sat.disconnect(); // Disconnects sat & hides line
                     return sat;
                 }
                 return null;
            }

             processQueue(currentTime) { /* ... (same logic, includes distance check) ... */
                 if (!this.isOnline()) return 0;
                 let connectedCount = 0;
                 const queueCopy = [...this.queue];
                 for (const sat of queueCopy) {
                      if (!this.hasCapacity()) break;
                     if (sat.connectedToStationId === null && !sat.isDamaged()) {
                          const d = distance(sat.position, this.position);
                           if (d <= MAX_CONNECTION_DISTANCE) {
                               if (this.connectSatellite(sat, currentTime)) {
                                   this.queue = this.queue.filter(s => s.id !== sat.id);
                                   logEvent(currentTime, "CONNECT", `Sat-${sat.id} connected to Sta-${this.id} from queue.`);
                                   connectedCount++;
                               } // else { logEvent(currentTime, "INFO", `Sta-${this.id} failed connecting Sat-${sat.id} from queue.`); }
                           } else { // Moved out of range while queued
                               logEvent(currentTime, "INFO", `Sat-${sat.id} removed from Sta-${this.id} queue (out of range).`);
                               this.queue = this.queue.filter(s => s.id !== sat.id);
                               // sat.setQueued(false); // No visual change
                           }
                     } else { // Already connected or damaged
                          this.queue = this.queue.filter(s => s.id !== sat.id);
                          // sat.setQueued(false); // No visual change
                     }
                  }
                 return connectedCount;
            }

             updateDOMState() { /* ... (same logic) ... */
                 this.domElement.classList.toggle('offline', !this.isOnline());
             }
        }

        // --- Simulation Logic ---

        function initializeSimulation() {
            simulationTimeSeconds = 0;
            logCounter = 0;
            satellites = [];
            stations = [];
            // Clear previous dynamic elements (stations, satellites, stars, lines)
            simArea.innerHTML = ''; // Clear stations/sats/stars
            simArea.appendChild(earthElement); // Add earth back
            simArea.appendChild(svgLines); // Add SVG layer back
            svgLines.innerHTML = ''; // Clear old lines from SVG
            logContent.innerHTML = '';

            // Get sim area dimensions needed for coordinate conversion
             simAreaRect = simArea.getBoundingClientRect();

             // Create Stars
             createStars(NUM_STARS);

            // Create Stations on Earth's edge
            for (let i = 0; i < NUM_STATIONS; i++) {
                const capacity = STATION_CAPACITIES[i] || 2;
                const stationAngle = (i / NUM_STATIONS) * 2 * Math.PI + (Math.PI / 4); // Start at 45deg, space evenly
                const position = {
                     x: EARTH_CENTER.x + EARTH_RADIUS_PERCENT * Math.cos(stationAngle),
                     y: EARTH_CENTER.y + EARTH_RADIUS_PERCENT * Math.sin(stationAngle)
                 };
                const maintenance = STATION_MAINTENANCE[i];
                const station = new GroundStation(i, capacity, position, maintenance);
                stations.push(station);
                logEvent(0, "INIT", `Station-${i} created on Earth @ ${stationAngle.toFixed(2)}rad`);
            }

            // Create Satellites
             for (let i = 0; i < NUM_SATELLITES; i++) {
                const isPriority = Math.random() < PRIORITY_SATELLITE_PROBABILITY;
                const initialData = SATELLITE_DATA_MIN_GB + Math.random() * (SATELLITE_DATA_MAX_GB - SATELLITE_DATA_MIN_GB);
                const sat = new Satellite(i, isPriority, initialData, SATELLITE_DATA_LIMIT_PER_CONTACT_GB);
                if (Math.random() < DAMAGED_SATELLITE_PROBABILITY) { sat.setDamaged(); logEvent(0, "INIT", `Sat-${i} created (DAMAGED)`); }
                else { logEvent(0, "INIT", `Sat-${i} created (Data:${initialData.toFixed(1)}GB)`); }
                satellites.push(sat);
            }
            updateDisplay();
             logEvent(0, "INIT", "Simulation Initialized.");
        }

        function simulationStep() {
             const currentTime = simulationTimeSeconds;
             const deltaTime = SIM_STEP_SECONDS;

             // Refresh sim area bounds in case of resize (debounced would be better)
             simAreaRect = simArea.getBoundingClientRect();

             // 0. Update Satellite Positions FIRST (this now also updates lines if connected)
             satellites.forEach(sat => sat.updatePosition(deltaTime));

            // 1. Update Station Status (Maintenance)
            stations.forEach(station => station.updateStatus(currentTime));

            // 2. Process Station Queues (Connect waiting)
            stations.forEach(station => station.processQueue(currentTime));

            // 3. Satellites Attempt Connections
             satellites.forEach(sat => {
                 if (sat.needsConnection()) {
                     let bestStation = null;
                     let minDistance = MAX_CONNECTION_DISTANCE + 1;
                    stations.forEach(station => {
                         if (station.isOnline()) {
                            const d = distance(sat.position, station.position);
                            if (d <= MAX_CONNECTION_DISTANCE && d < minDistance) {
                                // Basic line-of-sight check (is station "in front" of earth?)
                                // Vector from earth center to satellite
                                const Vsat = { x: sat.position.x - EARTH_CENTER.x, y: sat.position.y - EARTH_CENTER.y };
                                // Vector from earth center to station
                                const Vsta = { x: station.position.x - EARTH_CENTER.x, y: station.position.y - EARTH_CENTER.y };
                                // Dot product indicates angle between them
                                const dotProduct = Vsat.x * Vsta.x + Vsat.y * Vsta.y;
                                // If dot product is positive, angle < 90 deg, roughly visible
                                if (dotProduct > 0) {
                                     minDistance = d;
                                     bestStation = station;
                                } // Else: station is likely behind the earth from sat's POV
                            }
                         }
                    });
                    if (bestStation) {
                        if (bestStation.hasCapacity()) { if(bestStation.connectSatellite(sat, currentTime)) { logEvent(currentTime, "CONNECT", `Sat-${sat.id} connected to Sta-${bestStation.id}.`); }}
                        else { bestStation.addToQueue(sat, currentTime); }
                    }
                 }
             });

            // 4. Data Transmission & 5. Disconnection Check
             stations.forEach(station => {
                 if (!station.isOnline()) return;
                 const connectedIds = Object.keys(station.connectedSatellites);
                 connectedIds.forEach(satId => {
                      if (!station.connectedSatellites[satId]) return;
                      const sat = station.connectedSatellites[satId];
                      sat.transmitData(deltaTime, currentTime); // Includes range check
                      if (station.connectedSatellites[satId]) { // Check if still connected
                          let disconnectReason = null;
                          if (sat.dataToSend <= 0) { disconnectReason = "Data transfer complete"; }
                          else if (sat.dataSentThisContact >= sat.dataLimitPerContact) { disconnectReason = `Contact data limit reached`; }
                          if (disconnectReason) { station.disconnectSatellite(satId); logEvent(currentTime, "DISCONNECT", `Sat-${sat.id} disconnected from Sta-${station.id}. Reason: ${disconnectReason}.`); }
                      }
                  });
             });

            // Advance simulation time
            simulationTimeSeconds += deltaTime;
            updateDisplay(); // Update time
        }

        function updateDisplay() {
             simTimeDisplay.textContent = `Sim Time: ${formatTime(simulationTimeSeconds)}`;
        }

        function startSimulation() { /* ... (same as before) ... */
             if (simulationIntervalId === null) {
                 initializeSimulation();
                 simulationIntervalId = setInterval(simulationStep, UPDATE_INTERVAL_MS);
                 startBtn.disabled = true; stopBtn.disabled = false;
                 logEvent(simulationTimeSeconds,"START", "Simulation Started.");
             }
         }

        function stopSimulation() { /* ... (same as before) ... */
             if (simulationIntervalId !== null) {
                 clearInterval(simulationIntervalId); simulationIntervalId = null;
                 startBtn.disabled = false; stopBtn.disabled = true;
                  logEvent(simulationTimeSeconds,"STOP", "Simulation Stopped.");
            }
         }

        // --- Initialization and Event Listeners ---
        window.onload = () => { /* ... (same as before) ... */
             startBtn.addEventListener('click', startSimulation);
             stopBtn.addEventListener('click', stopSimulation);
             startBtn.disabled = false; stopBtn.disabled = true;
             simTimeDisplay.textContent = `Sim Time: ${formatTime(0)}`;
         };

    </script>

</body>
</html>